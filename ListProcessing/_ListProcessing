/*===================================================================================
 |              SAS List Processing Utility Macros
 |
 |    Author:  see individual snippets
 | Collector:  Jiangtang Hu (Jiangtanghu.com)
 |  Archived:  https://github.com/Jiangtang/Programming-SAS/tree/master/ListProcessing
 |
 +-------List Creating---------------------------------------------------------------
 |
 | %range produces a sequence like 1 2 3 or f1 f2 f3 or 1a 2a 3a
 |
 +-------List Manipulation-----------------------------------------------------------
 |
 | %zip:   zips two lists together by joining correponding elements, see, a b and c d ==> ac bd
 | %xprod: take cross product of two lists, see, a b and c d ==> ac ad bc bd
 |
 |
 | %replace: replace symbolic variable in block of code with each element of a list, see
 |    a b and code = #=__#  ==> a=__a b=__b
 |
 | %pt:        add quotes to each element in a list
 | %upt:       remove quotes from each element of a list
 | %changesep: change the separator for a list
 |
 |
 +==================================================================================*/
%macro changesep(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , osep=%str(,) /* separator for rteurned list */
     ) ;
 
 /* L (or &LV) is list of quoted items separated by LSEP
 return unquoted list of items separated by OSEP
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and CHG_: should be avoided for variable names.

 examples:
    %put %changesep ( l=a b c, lv= , lsep= %str( ), osep=%str(,) );

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local chg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %if %superq(osep)= %str( ) %then
     %do ;
         %let chg_list = %qsysfunc(strip(%superq(&lv))) ;
         %let chg_list = %qsysfunc(compbl(&chg_list)) ;
     %end ;
     %else
     %let chg_list = %superq(&lv) ;
     %let chg_list = %qsysfunc(translate(&chg_list,&osep,&lsep)) ;
 %end ;
 %unquote(&chg_list)
%mend changesep ;
%macro qt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     , osep=%str( ) /* separtor for returned list */
     ) ;

 /* List of items separated by &lsep
     Return items in list quoted with &qt, and separated with &osep
     if lsep is not %STR( ) then there can be only one separator between items.
     Note: leading and trailing spaces are stripped from list when LSEP is %STR( ).
     LV provides override to specify external variable name instead list.
     If the LV option is used then L and QT_: should be avoided for variable names.

examples:
    %put %qt(l=a b c,osep=%str(,));

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf

 */

 %local qt_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %superq(lsep) = %str( ) and %length(&lsep)=1 %then
 %do ;
     %let qt_list = %qsysfunc(strip(%superq(&lv))) ;
     %if %length(&qt_list) > 0 %then
     %let qt_list = %qsysfunc(compbl(&qt_list)) ;
 %end ;
 %else
     %let qt_list = %superq(&lv) ;
 %if %length(&qt_list) > 0 %then
     %do ;
     %unquote(&qt%qsysfunc(tranwrd( &qt_list
     , &lsep
     , &qt&osep&qt
     )
     )&qt
     )
 %end ;
%mend qt ;
%macro range (
       to  =        /* end integer value */
     , from=1       /* starting integer value */
     , step=1       /* increment integer */
     , osep=%str( ) /* separator between integers */
     , opre=%str()  /* prefix for sequence of integers*/
     , osuf=%str()  /* suffix for sequence of integers*/
     ) ;

/*
return sequence of integers like 1 2 3 or
    strings ended with sequences of integers like data1 data2 data3
    starting at &FROM going to &TO in steps of &step

examples:
   %put %range(to=10);
   %put %range(to=10, opre=%str(data));
   %put %range(from=2,to=10,step=3,osep=%str(,));
   %put %range(from=2,to=10,step=3,osep=%str(,),osuf=%str(a));

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
    This snippet used a more efficient style from Chang Chung(http://changchung.com)
    Jiangtang Hu (2013, http://www.jiangtanghu.com):
        1)used %let rg_i = ; to initiate the macro variable rather than %local rg_i;
        2)added two parameters (prefix/suffix) so it works more than generating sequence of integers
        3)archived in https://github.com/Jiangtang/Programming-SAS/tree/master/ListProcessing
*/

 %let rg_i = ;
 %do rg_i = &from %to &to %by &step ;
     %if &rg_i = &from %then
     %do;&opre.&rg_i.&osuf%end ;
     %else
     %do;&osep.&opre.&rg_i.&osuf%end ;
 %end ;
%mend range ;
%macro replace(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , code=        /* block of code containing symbolic variable */
     , key=#        /* symbolic variable to replace (#abc# etc.) */
     , osep=%str( ) /* separator between new elements */
                    /* may be %str(;) when code is statement */
                    /* if so remember to add closing semicolon */
     ) ;

 /* for elt in the list replace key in code
     LV provides override to specify external variable name instead of list.
     If the LV option is used then L and RG_: should be avoided for variable names.

examples:
    %macro rename ( list, pref=__ ) ;
         %* make a rename list from &LIST *;
         %replace ( l=&list, code = # = &pref# )
    %mend rename ;
    %put %rename ( x y z, pref=__ );

     %macro char2num ( list , pref = __ ) ;
     %* make list of char to num assignments *;
     %replace ( l=&list
        , code= %str(# = input(&pref#,best32.);)
      )
    %mend char2num ;
    %put %char2num(x y z);

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local rg_i rg_w rg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) = 0 /*or %index(%superq(code),&key) = 0*/ %then
 %do ;
     %let rg_list = %superq(code) ;
     %goto mexit ;
 %end ;
 %do rg_i = 1 %to &sysmaxlong ;
     %let rg_w = %qscan(%superq(&lv),&rg_i,&lsep) ;
     %if %length(&rg_w) = 0 %then %goto mexit ;
     %if &rg_i = 1 %then
     %let rg_list = %sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
     %else
     %let rg_list =
     &rg_list&osep%sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
 %end ;
 %mexit:

 %unquote(&rg_list)
%mend replace ;
%macro uqt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     ) ;

 /* L (or &LV) is list of quoted items separated by LSEP

 return unquoted list of items separated by space
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and UQT_: should be avoided for variable names.

examples:
    %put %Uqt(l="a" "b" "c");

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %sysfunc(compbl(%sysfunc(translate(%superq(&lv),%str( ),&qt&lsep))))
 %end ;
%mend uqt ;
%macro xprod(
     l1  =        /* first list */
   , lv1 =        /* external variable override for first list */
   , sep1=%str( ) /* separator between elements of first list */
   , l2  =        /* second list */
   , lv2 =        /* external variable override for second list */
   , sep2=%str( ) /* separator between elements of second list */
   , osep=%str( ) /* separator between elements of new list */
 );

 /* %xprod ( l1= a b , l2= c d ) produces ac ad bc bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %xprod (lv1=list1, lv2=list2);
 %put %xprod (lv1=list1, lv2=list2,osep=%str(,));

 LV1 and LV2 provide override to specify external variable name instead of lists.
 If one or more of the lists are empty then the empty list is returned.
 If the LV options are used then L1, L2, and XP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
        (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
        (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local xp_i xp_j xp_1 xp_2 xp_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do xp_i = 1 %to &sysmaxlong ;
   %let xp_1 = %qscan(%superq(&lv1), &xp_i, &sep1) ;
   %if %length(&xp_1) = 0 %then %goto endloop1 ;
   %do xp_j = 1 %to &sysmaxlong ;
     %let xp_2 = %qscan(%superq(&lv2), &xp_j, &sep2) ;
     %if %length(&xp_2) = 0 %then %goto endloop2 ;
     %if &xp_i = 1 and &xp_j = 1 %then
     %let xp_list = &xp_1&xp_2 ;
     %else
     %let xp_list = &xp_list&osep&xp_1&xp_2 ;
   %end ;
   %endloop2:
 %end ;
 %endloop1:
 %unquote(&xp_list)
%mend xprod ;
%macro zip(
       l1   =        /* first list */
     , lv1 =        /* external variable override for first list */
     , sep1 =%str( ) /* separator between the joined elements */
     , l2   =        /* second list */
     , lv2  =        /* external variable override for second list */
     , sep2 =%str( ) /* separator between the joined elements */
     , osep =%str( ) /* separator between new elements */
     ) ;

 /* %zip ( l1= a b , l2= c d ) produces ac bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %zip (lv1=list1, lv2=list2);
 %put %zip (lv1=list1, lv2=list2,osep =%str(,));

 If lists do not have same length shorter length used and warning to the log.
 Empty lists result in empty list and no message.
 If the LV options are used then L1, L2, and ZIP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
          (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
          (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local zip_i zip_1 zip_2 zip_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do zip_i = 1 %to &sysmaxlong ;
   %let zip_1 = %qscan(%superq(&lv1) , &zip_i, &sep1 ) ;
   %let zip_2 = %qscan(%superq(&lv2) , &zip_i, &sep2 ) ;
   %if %length(&zip_1) = 0 or %length(&zip_2) = 0 %then
   %goto check ;
   %if &zip_i = 1 %then
   %let zip_list = &zip_1&zip_2 ;
   %else
   %let zip_list = &zip_list&osep&zip_1&zip_2 ;
 %end ;
 %check:
 %if %length(&zip_1) > 0 or %length(&zip_2) > 0 %then
 %put WARNING: Macro ZIP - list lengths do not match - shorter used. ;
 %unquote(&zip_list)
%mend zip ;
